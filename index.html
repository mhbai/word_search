<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Word Search æ‰¾å­—éŠæˆ²</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&display=swap');
        
        body {
            font-family: 'Fredoka', sans-serif;
            background-color: #f0fdf4;
            overscroll-behavior-y: contain; 
        }

        #grid-container {
            touch-action: none; 
            user-select: none;
            -webkit-user-select: none;
        }

        .cell {
            transition: transform 0.1s;
        }

        .highlight-line {
            stroke-dasharray: 100;
            stroke-dashoffset: 100;
            animation: drawLine 0.4s ease-out forwards;
        }
        
        @keyframes drawLine {
            to { stroke-dashoffset: 0; }
        }

        .word-item {
            transition: all 0.3s ease;
        }
        .word-item.found {
            text-decoration: line-through;
            color: #9ca3af;
            opacity: 0.6;
        }
        .word-item.revealed {
            color: #ef4444; 
            font-weight: bold;
        }
        
        @keyframes popIn {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        .animate-pop-in {
            animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        option:disabled {
            color: #cbd5e1; 
            background-color: #f1f5f9;
        }
    </style>
</head>
<body class="min-h-screen text-slate-800 py-8 px-4 flex flex-col items-center">

    <div class="max-w-4xl w-full">
        <!-- æ¨™é¡Œèˆ‡æ§åˆ¶åˆ— -->
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold text-green-600 mb-4 flex items-center justify-center gap-3">
                <svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-green-500"><path d="m10 17 4-4-4-4"/><path d="M14 17l4-4-4-4"/><path d="M4 17l4-4-4-4"/></svg>
                Word Search
            </h1>
            <p class="text-slate-500 mb-6">çœ‹ä¸­æ–‡æç¤ºï¼Œæ‰¾å‡ºéš±è—çš„è‹±æ–‡å–®å­—ï¼ï¼ˆæ”¯æ´æ»‘é¼ æ‹–æ›³æˆ–æ‰‹æ©Ÿæ»‘å‹•ï¼‰</p>
            
            <div class="flex flex-wrap items-center justify-center gap-4 bg-white p-4 rounded-2xl shadow-sm border border-green-100">
                <div class="flex items-center gap-2">
                    <label for="level-select" class="font-medium text-slate-600">é›£åº¦ï¼š</label>
                    <select id="level-select" class="bg-slate-50 border border-slate-200 text-slate-700 rounded-lg focus:ring-green-500 focus:border-green-500 block p-2 outline-none">
                        <option value="1">Level 1</option>
                        <option value="2">Level 2</option>
                        <option value="3">Level 3</option>
                        <option value="4">Level 4</option>
                        <option value="5">Level 5</option>
                        <option value="6">Level 6</option>
                    </select>
                </div>
                <div class="flex items-center gap-2">
                    <label for="stage-select" class="font-medium text-slate-600">é—œå¡ï¼š</label>
                    <select id="stage-select" class="bg-slate-50 border border-slate-200 text-slate-700 rounded-lg focus:ring-green-500 focus:border-green-500 block p-2 outline-none">
                        <!-- å‹•æ…‹ç”Ÿæˆé—œå¡é¸é … -->
                    </select>
                </div>
                
                <div class="flex gap-2">
                    <button id="btn-restart" class="bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:shadow-lg transition-all active:scale-95 flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                        é‡ä¾†
                    </button>
                    <!-- èªè¼¸æŒ‰éˆ• -->
                    <button id="btn-giveup" class="bg-red-400 hover:bg-red-500 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:shadow-lg transition-all active:scale-95 flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M15 9l-6 6"/><path d="M9 9l6 6"/></svg>
                        èªè¼¸
                    </button>
                    <!-- ä¸Šæ–¹ä¸‹ä¸€é—œæŒ‰éˆ• -->
                    <button id="btn-header-next" class="hidden bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:shadow-lg transition-all active:scale-95 flex items-center gap-2">
                        ä¸‹ä¸€é—œ â¡ï¸
                    </button>
                </div>
            </div>
        </header>

        <!-- éŠæˆ²ä¸»è¦å€åŸŸ -->
        <main class="flex flex-col lg:flex-row gap-8 items-start justify-center">
            
            <!-- å­—æ¯ç¶²æ ¼å€ -->
            <div class="w-full max-w-lg mx-auto bg-white p-2 md:p-4 rounded-2xl shadow-xl border border-slate-100 relative">
                <!-- ç¶²æ ¼ -->
                <div id="grid-container" class="grid gap-[2px] md:gap-1 w-full aspect-square relative touch-none">
                    <svg id="highlight-layer" class="absolute inset-0 w-full h-full pointer-events-none z-10 mix-blend-multiply opacity-80"></svg>
                </div>
                
                <!-- å‹åˆ©/å¤±æ•—è¦†è“‹å±¤ -->
                <div id="win-overlay" class="hidden absolute inset-0 bg-white/95 backdrop-blur-sm rounded-2xl flex flex-col items-center justify-center z-20 animate-pop-in p-4 text-center border-4 border-slate-100">
                    <button id="btn-close-overlay" class="absolute top-4 right-4 text-slate-400 hover:text-slate-600 transition-colors p-2 hover:bg-slate-100 rounded-full" title="é—œé–‰è¦–çª—">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                    </button>

                    <div id="overlay-icon" class="text-6xl mb-4">ğŸ‰</div>
                    <h2 id="overlay-title" class="text-3xl font-bold text-green-600 mb-2">å¤ªå²å®³äº†ï¼</h2>
                    <p id="overlay-message" class="text-slate-600 mb-6 font-medium">ä½ æ‰¾åˆ°äº†æ‰€æœ‰çš„å–®å­—ï¼</p>
                    
                    <div class="flex flex-wrap gap-3 justify-center">
                        <button id="btn-view-board" class="bg-slate-100 hover:bg-slate-200 text-slate-600 font-bold py-3 px-6 rounded-full shadow transition-transform hover:scale-105 active:scale-95 flex items-center gap-2">
                            ğŸ‘€ æŸ¥çœ‹ç›¤é¢
                        </button>
                        <button id="btn-play-again" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-full shadow-lg transition-transform hover:scale-105 active:scale-95 hidden">
                            å†ä¾†ä¸€å±€
                        </button>
                        <button id="btn-next-level" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-full shadow-lg transition-transform hover:scale-105 active:scale-95">
                            ä¸‹ä¸€é—œ â¡ï¸
                        </button>
                    </div>
                </div>
            </div>

            <!-- å–®å­—åˆ—è¡¨å€ -->
            <div class="w-full lg:w-64 bg-white p-6 rounded-2xl shadow-md border border-slate-100">
                <h3 class="text-xl font-bold text-slate-700 mb-4 border-b pb-2 flex justify-between items-center">
                    <span>å°‹æ‰¾å–®å­—</span>
                    <span id="progress-text" class="text-sm font-medium bg-green-100 text-green-700 py-1 px-2 rounded-md">0 / 0</span>
                </h3>
                <ul id="word-list" class="grid grid-cols-2 lg:grid-cols-1 gap-y-3 gap-x-4 text-lg font-medium text-slate-600">
                    <!-- Word items here -->
                </ul>
            </div>
            
        </main>
    </div>

    <script>
        // === æ ¸å¿ƒå·¥å…·ï¼šå½éš¨æ©Ÿæ•¸ç”Ÿæˆå™¨ (PRNG) ===
        // Mulberry32 æ¼”ç®—æ³•ï¼šè¼¸å…¥ä¸€å€‹ seedï¼Œå›å‚³ä¸€å€‹ç”¢ç”Ÿ 0-1 éš¨æ©Ÿæ•¸çš„å‡½å¼
        function mulberry32(a) {
            return function() {
                var t = a += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }

        // ç¢ºå®šæ€§æ´—ç‰Œæ¼”ç®—æ³• (Fisher-Yates with seeded RNG)
        // åªè¦ seed ä¸€æ¨£ï¼Œæ´—å‡ºä¾†çš„é™£åˆ—é †åºå°±æ°¸é ä¸€æ¨£
        function seededShuffle(array, seed) {
            const rng = mulberry32(seed);
            let m = array.length, t, i;
            while (m) {
                i = Math.floor(rng() * m--);
                t = array[m];
                array[m] = array[i];
                array[i] = t;
            }
            return array;
        }

        // === éŠæˆ²è³‡æ–™èˆ‡è¨­å®š ===
        const LEVEL_SETTINGS = {
            1: { minGridSize: 6, maxGridSize: 12, minWords: 4, maxWords: 10 },
            2: { minGridSize: 8, maxGridSize: 14, minWords: 6, maxWords: 12 },
            3: { minGridSize: 10, maxGridSize: 16, minWords: 8, maxWords: 14 },
            4: { minGridSize: 12, maxGridSize: 18, minWords: 10, maxWords: 16 },
            5: { minGridSize: 14, maxGridSize: 20, minWords: 12, maxWords: 18 },
            6: { minGridSize: 16, maxGridSize: 22, minWords: 14, maxWords: 20 }
        };

        // === å–®å­—åº« ===
        const WORDS_DB = {
            1: [
                { en: 'CAT', zh: 'è²“' }, { en: 'DOG', zh: 'ç‹—' }, { en: 'LION', zh: 'ç…å­' }, { en: 'BEAR', zh: 'ç†Š' },
                { en: 'DUCK', zh: 'é´¨å­' }, { en: 'FROG', zh: 'é’è›™' }, { en: 'KITE', zh: 'é¢¨ç®' }, { en: 'ROSE', zh: 'ç«ç‘°' },
                { en: 'TIGER', zh: 'è€è™' }, { en: 'ZEBRA', zh: 'æ–‘é¦¬' }, { en: 'PANDA', zh: 'ç†Šè²“' }, { en: 'SNAKE', zh: 'è›‡' },
                { en: 'APPLE', zh: 'è˜‹æœ' }, { en: 'LEMON', zh: 'æª¸æª¬' }, { en: 'GRAPE', zh: 'è‘¡è„' }, { en: 'WATER', zh: 'æ°´' },
                { en: 'RABBIT', zh: 'å…”å­' }, { en: 'MONKEY', zh: 'çŒ´å­' }, { en: 'ORANGE', zh: 'æ©˜å­' }, { en: 'BANANA', zh: 'é¦™è•‰' },
                { en: 'SUN', zh: 'å¤ªé™½' }, { en: 'HAT', zh: 'å¸½å­' }, { en: 'RUN', zh: 'è·‘' }, { en: 'FUN', zh: 'æœ‰è¶£' }
            ], 
            2: [
                { en: 'BIRD', zh: 'é³¥' }, { en: 'FISH', zh: 'é­š' }, { en: 'TREE', zh: 'æ¨¹' }, { en: 'STAR', zh: 'æ˜Ÿæ˜Ÿ' }, 
                { en: 'MOON', zh: 'æœˆäº®' }, { en: 'TIME', zh: 'æ™‚é–“' }, { en: 'PLAY', zh: 'ç©' }, { en: 'BLUE', zh: 'è—è‰²' }, 
                { en: 'BOOK', zh: 'æ›¸' }, { en: 'DESK', zh: 'æ›¸æ¡Œ' }, { en: 'RAIN', zh: 'é›¨' }, { en: 'SNOW', zh: 'é›ª' },
                { en: 'WIND', zh: 'é¢¨' }, { en: 'FIRE', zh: 'ç«' }, { en: 'COLD', zh: 'å†·' }, { en: 'WARM', zh: 'æº«æš–' },
                { en: 'FAST', zh: 'å¿«' }, { en: 'SLOW', zh: 'æ…¢' }, { en: 'GOOD', zh: 'å¥½' }, { en: 'NICE', zh: 'å¾ˆå¥½' }
            ],
            3: [
                { en: 'APPLE', zh: 'è˜‹æœ' }, { en: 'TIGER', zh: 'è€è™' }, { en: 'WATER', zh: 'æ°´' }, { en: 'SMILE', zh: 'å¾®ç¬‘' }, 
                { en: 'HOUSE', zh: 'æˆ¿å­' }, { en: 'TRAIN', zh: 'ç«è»Š' }, { en: 'MOUSE', zh: 'è€é¼ ' }, { en: 'GREEN', zh: 'ç¶ è‰²' }, 
                { en: 'RIVER', zh: 'æ²³æµ' }, { en: 'CHAIR', zh: 'æ¤…å­' }, { en: 'TABLE', zh: 'æ¡Œå­' }, { en: 'CLOCK', zh: 'æ™‚é˜' },
                { en: 'PHONE', zh: 'é›»è©±' }, { en: 'MUSIC', zh: 'éŸ³æ¨‚' }, { en: 'LIGHT', zh: 'å…‰/ç‡ˆ' }, { en: 'NIGHT', zh: 'å¤œæ™š' },
                { en: 'DREAM', zh: 'å¤¢' }, { en: 'HEART', zh: 'å¿ƒ' }
            ],
            4: [
                { en: 'BANANA', zh: 'é¦™è•‰' }, { en: 'MONKEY', zh: 'çŒ´å­' }, { en: 'WINTER', zh: 'å†¬å¤©' }, { en: 'SUMMER', zh: 'å¤å¤©' }, 
                { en: 'SCHOOL', zh: 'å­¸æ ¡' }, { en: 'NATURE', zh: 'è‡ªç„¶' }, { en: 'ANIMAL', zh: 'å‹•ç‰©' }, { en: 'PURPLE', zh: 'ç´«è‰²' }, 
                { en: 'PLANET', zh: 'æ˜Ÿçƒ' }, { en: 'ROCKET', zh: 'ç«ç®­' }, { en: 'GUITAR', zh: 'å‰ä»–' }, { en: 'CAMERA', zh: 'ç›¸æ©Ÿ' },
                { en: 'ISLAND', zh: 'å³¶å¶¼' }, { en: 'FOREST', zh: 'æ£®æ—' }, { en: 'DESERT', zh: 'æ²™æ¼ ' }, { en: 'OCEAN', zh: 'æµ·æ´‹' }
            ],
            5: [
                { en: 'ELEPHANT', zh: 'å¤§è±¡' }, { en: 'COMPUTER', zh: 'é›»è…¦' }, { en: 'INTERNET', zh: 'ç¶²è·¯' }, { en: 'BASEBALL', zh: 'æ£’çƒ' }, 
                { en: 'HOSPITAL', zh: 'é†«é™¢' }, { en: 'VACATION', zh: 'å‡æœŸ' }, { en: 'MOUNTAIN', zh: 'å±±' }, { en: 'KEYBOARD', zh: 'éµç›¤' }, 
                { en: 'UNIVERSE', zh: 'å®‡å®™' }, { en: 'DINOSAUR', zh: 'æé¾' }, { en: 'UMBRELLA', zh: 'é›¨å‚˜' }, { en: 'SANDWICH', zh: 'ä¸‰æ˜æ²»' },
                { en: 'ASTRONAUT', zh: 'å¤ªç©ºäºº' }
            ],
            6: [
                { en: 'JAVASCRIPT', zh: 'JSèªè¨€' }, { en: 'PROGRAMMING', zh: 'ç¨‹å¼è¨­è¨ˆ' }, { en: 'EXPERIENCE', zh: 'ç¶“é©—' }, { en: 'DEVELOPMENT', zh: 'é–‹ç™¼' }, 
                { en: 'UNIVERSITY', zh: 'å¤§å­¸' }, { en: 'GOVERNMENT', zh: 'æ”¿åºœ' }, { en: 'TECHNOLOGY', zh: 'ç§‘æŠ€' }, { en: 'ENVIRONMENT', zh: 'ç’°å¢ƒ' }, 
                { en: 'UNDERSTAND', zh: 'äº†è§£' }, { en: 'DICTIONARY', zh: 'å­—å…¸' }, { en: 'ARCHITECT', zh: 'å»ºç¯‰å¸«' }
            ]
        };

        let GRID_SIZE = 12; 
        let generatedStagesCache = {}; 
        const DIRECTIONS = [
            [0, 1], [1, 0], [1, 1], [-1, 1],
            [0, -1], [-1, 0], [-1, -1], [1, -1]
        ];

        // === éŠæˆ²ç‹€æ…‹ ===
        let currentWords = [];
        let grid = [];
        let foundWords = new Set();
        let solutionPaths = {}; 
        let isGameActive = true; 
        let maxUnlocked = loadProgress(); 

        // === äº’å‹•ç‹€æ…‹ ===
        let isSelecting = false;
        let startCell = null;
        let currentSelectionLine = [];
        let foundCellCoordinates = new Set(); 

        // === DOM å…ƒç´  ===
        const gridContainer = document.getElementById('grid-container');
        const highlightLayer = document.getElementById('highlight-layer');
        const wordListContainer = document.getElementById('word-list');
        const levelSelect = document.getElementById('level-select');
        const stageSelect = document.getElementById('stage-select');
        const btnRestart = document.getElementById('btn-restart');
        const btnGiveUp = document.getElementById('btn-giveup'); 
        const btnHeaderNext = document.getElementById('btn-header-next'); 
        const btnPlayAgain = document.getElementById('btn-play-again');
        const btnNextLevel = document.getElementById('btn-next-level');
        const btnViewBoard = document.getElementById('btn-view-board'); 
        const btnCloseOverlay = document.getElementById('btn-close-overlay'); 
        const winOverlay = document.getElementById('win-overlay');
        const overlayIcon = document.getElementById('overlay-icon');
        const overlayTitle = document.getElementById('overlay-title');
        const overlayMessage = document.getElementById('overlay-message');
        const progressText = document.getElementById('progress-text');

        // === é€²åº¦å­˜å–åŠŸèƒ½ ===
        function loadProgress() {
            try {
                const stored = localStorage.getItem('wordSearchProgress');
                return stored ? JSON.parse(stored) : { level: 1, stage: 1 };
            } catch (e) {
                return { level: 1, stage: 1 };
            }
        }

        function saveProgress(level, stage) {
            if (level > maxUnlocked.level || (level === maxUnlocked.level && stage > maxUnlocked.stage)) {
                maxUnlocked = { level, stage };
                localStorage.setItem('wordSearchProgress', JSON.stringify(maxUnlocked));
                updateLevelDropdownState();
                updateStageDropdown(parseInt(levelSelect.value));
            }
        }
        
        function updateLevelDropdownState() {
            Array.from(levelSelect.options).forEach(opt => {
                const val = parseInt(opt.value);
                const originalText = opt.text.replace('ğŸ”’ ', '');
                if (val > maxUnlocked.level) {
                    opt.disabled = true;
                    opt.textContent = `ğŸ”’ ${originalText}`;
                } else {
                    opt.disabled = false;
                    opt.textContent = originalText;
                }
            });
        }

        // === éŠæˆ²ç”Ÿæˆé‚è¼¯ (ä½¿ç”¨å›ºå®šç¨®å­) ===

        function getOrGenerateStages(levelNum) {
            if (generatedStagesCache[levelNum]) {
                return generatedStagesCache[levelNum];
            }

            const settings = LEVEL_SETTINGS[levelNum];
            
            // --- é—œéµä¿®æ”¹ï¼šä½¿ç”¨å›ºå®šç¨®å­ (Level ID) ä¾†æ´—ç‰Œ ---
            // é€™ä¿è­‰äº†å°æ–¼åŒä¸€å€‹ Levelï¼Œå–®å­—çš„æ’åˆ—é †åºæ°¸é æ˜¯å›ºå®šçš„
            // é€™æ¨£ç¬¬1é—œæ°¸é æ˜¯åŒä¸€æ‰¹å­—ï¼Œç¬¬2é—œæ˜¯ä¸‹ä¸€æ‰¹å­—ï¼Œä¸æœƒé‡è¤‡ä¹Ÿä¸æœƒæ¼æ‰
            let availableWords = seededShuffle([...WORDS_DB[levelNum]], levelNum);
            
            let stages = [];
            let stageIndex = 0;

            while (availableWords.length > 0) {
                let progressRatio = Math.min(stageIndex / 50, 1);
                let currentGridSize = Math.floor(settings.minGridSize + progressRatio * (settings.maxGridSize - settings.minGridSize));
                let currentWordCount = Math.floor(settings.minWords + progressRatio * (settings.maxWords - settings.minWords));

                let wordsToPick = Math.min(currentWordCount, availableWords.length);
                let stageWords = [];

                for (let i = 0; i < availableWords.length && stageWords.length < wordsToPick; i++) {
                    if (availableWords[i].en.length <= currentGridSize) {
                        stageWords.push(availableWords[i]);
                        availableWords.splice(i, 1);
                        i--; 
                    }
                }

                if (stageWords.length === 0 && availableWords.length > 0) {
                    let minLenIndex = 0;
                    for(let k=1; k<availableWords.length; k++){
                        if(availableWords[k].en.length < availableWords[minLenIndex].en.length){
                            minLenIndex = k;
                        }
                    }
                    currentGridSize = Math.max(currentGridSize, availableWords[minLenIndex].en.length);
                    stageWords.push(availableWords[minLenIndex]);
                    availableWords.splice(minLenIndex, 1);
                }

                stages.push({
                    gridSize: currentGridSize,
                    words: stageWords
                });

                stageIndex++;
                if (stageIndex >= 500) break;
            }

            generatedStagesCache[levelNum] = stages;
            return stages;
        }
        
        function updateStageDropdown(levelNum) {
            const stages = getOrGenerateStages(levelNum);
            const totalStages = stages.length || 1;
            
            let currentStageValue = parseInt(stageSelect.value) || 1;
            
            if (!stageSelect.value && levelNum === maxUnlocked.level) {
                 currentStageValue = maxUnlocked.stage;
            }

            stageSelect.innerHTML = '';
            for (let i = 1; i <= totalStages; i++) {
                const option = document.createElement('option');
                option.value = i;
                
                let isLocked = false;
                if (levelNum > maxUnlocked.level) {
                    isLocked = true;
                } else if (levelNum === maxUnlocked.level && i > maxUnlocked.stage) {
                    isLocked = true;
                }

                if (isLocked) {
                    option.disabled = true;
                    option.textContent = `ğŸ”’ ç¬¬ ${i} é—œ`;
                } else {
                    option.textContent = `ç¬¬ ${i} é—œ`;
                }

                if (i === currentStageValue) option.selected = true;
                stageSelect.appendChild(option);
            }
        }

        function initGame() {
            updateLevelDropdownState();
            const currentLevelNum = parseInt(levelSelect.value);
            
            if(stageSelect.options.length === 0 || !stageSelect.querySelector(`option[value="${stageSelect.value}"]`)) {
                 updateStageDropdown(currentLevelNum);
            }
            
            let currentStageNum = parseInt(stageSelect.value) || 1;
            if (currentLevelNum === maxUnlocked.level && currentStageNum > maxUnlocked.stage) {
                currentStageNum = maxUnlocked.stage;
                stageSelect.value = currentStageNum;
            }

            const stages = getOrGenerateStages(currentLevelNum);
            const currentStageData = stages[currentStageNum - 1];
            
            GRID_SIZE = currentStageData.gridSize;
            
            // ä½¿ç”¨ç¨®å­åˆå§‹åŒ–å–®å­—çš„æ’åˆ— (Level * 10000 + Stage)
            // é€™æ¨£æ¯ä¸€é—œçš„æ’ç‰ˆä¹Ÿæœƒå›ºå®š
            const stageSeed = currentLevelNum * 10000 + currentStageNum;
            // é€™è£¡ä¸éœ€è¦é‡æ´—é †åºï¼Œå› ç‚ºåœ¨ getOrGenerateStages å·²ç¶“æ´—éäº†ï¼Œç›´æ¥ç”¨
            // ä½†ç‚ºäº†è®“æ¼”åŒ–æ¼”ç®—æ³•æœ‰éš¨æ©Ÿèµ·å§‹é»ä½†åˆæ˜¯å›ºå®šçš„ï¼Œæˆ‘å€‘å‚³å…¥ seed çµ¦æ¼”ç®—æ³•
            const wordsToFit = [...currentStageData.words];

            gridContainer.style.gridTemplateColumns = `repeat(${GRID_SIZE}, minmax(0, 1fr))`;

            // å»ºç«‹è©²é—œå¡å°ˆå±¬çš„ RNG
            const stageRng = mulberry32(stageSeed);

            // === ä½¿ç”¨æ¼”åŒ–æ¼”ç®—æ³•ç”Ÿæˆæœ€ä½³ç›¤é¢ (å‚³å…¥å›ºå®š RNG) ===
            const evolutionResult = runEvolutionaryPlacement(wordsToFit, stageRng);
            
            grid = evolutionResult.grid;
            currentWords = evolutionResult.placedWords;
            solutionPaths = evolutionResult.paths;
            
            foundWords.clear();
            foundCellCoordinates.clear();
            isGameActive = true; 
            isSelecting = false;
            startCell = null;
            currentSelectionLine = [];

            highlightLayer.setAttribute('viewBox', `0 0 ${GRID_SIZE} ${GRID_SIZE}`);
            highlightLayer.innerHTML = '<line id="selection-line" stroke="#93c5fd" stroke-linecap="round" stroke-width="0.7" class="hidden" />';

            winOverlay.classList.add('hidden');
            btnGiveUp.classList.remove('hidden'); 
            btnGiveUp.disabled = false; 
            btnGiveUp.classList.remove('opacity-50', 'cursor-not-allowed');
            btnHeaderNext.classList.add('hidden'); 

            fillEmptySpaces(stageRng); // å¡«ç©ºå­—ä¹Ÿç”¨ RNG
            renderGrid();
            renderWordList();
            updateProgress();
        }

        // === æ¼”åŒ–æ¼”ç®—æ³•æ ¸å¿ƒ (Evolutionary Algorithm) - æ”¯æ´ Seed RNG ===
        function runEvolutionaryPlacement(words, rng) {
            const MAX_GENERATIONS = 15;
            let bestGrid = null;
            let bestScore = -1;
            let bestPlacedWords = [];
            let bestPaths = {};

            // åˆå§‹åŸºå› ï¼šä½¿ç”¨ seed æ‰“äº‚
            let currentOrder = seededShuffle([...words], Math.floor(rng() * 10000));

            for (let gen = 0; gen < MAX_GENERATIONS; gen++) {
                const result = tryBuildGrid(currentOrder, rng);
                
                let score = result.placedWords.length * 1000 + result.intersections * 10;

                if (score > bestScore) {
                    bestScore = score;
                    bestGrid = result.grid;
                    bestPlacedWords = result.placedWords;
                    bestPaths = result.paths;
                }

                // æ¼”åŒ–ï¼šå°‡å¤±æ•—çš„ç§»åˆ°å‰é¢ï¼Œå…¶é¤˜ç”¨ RNG éš¨æ©Ÿæ‰“äº‚
                if (result.failedWords.length > 0) {
                    const successfulShuffled = seededShuffle(result.placedWords.map(w => w.originalObj), Math.floor(rng() * 10000));
                    currentOrder = [...result.failedWords, ...successfulShuffled];
                } else {
                    currentOrder = seededShuffle(currentOrder, Math.floor(rng() * 10000));
                }
            }

            return {
                grid: bestGrid,
                placedWords: bestPlacedWords,
                paths: bestPaths
            };
        }

        function tryBuildGrid(orderedWords, rng) {
            let tempGrid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(''));
            let placedWords = [];
            let failedWords = [];
            let paths = {};
            let intersections = 0;

            for (const wordObj of orderedWords) {
                const word = wordObj.en;
                let placed = false;
                
                let attempts = 0;
                while (!placed && attempts < 50) { 
                    const dir = DIRECTIONS[Math.floor(rng() * DIRECTIONS.length)];
                    const r = Math.floor(rng() * GRID_SIZE);
                    const c = Math.floor(rng() * GRID_SIZE);
                    
                    if (canPlaceWordInGrid(tempGrid, word, r, c, dir[0], dir[1])) {
                        intersections += placeWordInGrid(tempGrid, word, r, c, dir[0], dir[1], paths);
                        placedWords.push(wordObj); 
                        placedWords[placedWords.length-1].originalObj = wordObj; 
                        placed = true;
                    }
                    attempts++;
                }

                if (!placed) {
                    const shuffledDirs = seededShuffle([...DIRECTIONS], Math.floor(rng() * 10000));
                    for (let r = 0; r < GRID_SIZE; r++) {
                        for (let c = 0; c < GRID_SIZE; c++) {
                            for (const dir of shuffledDirs) {
                                if (canPlaceWordInGrid(tempGrid, word, r, c, dir[0], dir[1])) {
                                    intersections += placeWordInGrid(tempGrid, word, r, c, dir[0], dir[1], paths);
                                    placedWords.push(wordObj);
                                    placedWords[placedWords.length-1].originalObj = wordObj;
                                    placed = true;
                                    break;
                                }
                            }
                            if (placed) break;
                        }
                        if (placed) break;
                    }
                }

                if (!placed) {
                    failedWords.push(wordObj);
                }
            }

            return { grid: tempGrid, placedWords, failedWords, paths, intersections };
        }

        function canPlaceWordInGrid(g, word, r, c, dr, dc) {
            const endR = r + (word.length - 1) * dr;
            const endC = c + (word.length - 1) * dc;
            if (endR < 0 || endR >= GRID_SIZE || endC < 0 || endC >= GRID_SIZE) {
                return false;
            }
            for (let i = 0; i < word.length; i++) {
                const cell = g[r + i * dr][c + i * dc];
                if (cell !== '' && cell !== word[i]) return false;
            }
            return true;
        }

        function placeWordInGrid(g, word, r, c, dr, dc, paths) {
            let path = [];
            let intersectCount = 0;
            for (let i = 0; i < word.length; i++) {
                const curR = r + i * dr;
                const curC = c + i * dc;
                if (g[curR][curC] !== '') {
                    intersectCount++; 
                }
                g[curR][curC] = word[i];
                path.push({r: curR, c: curC});
            }
            paths[word] = path;
            return intersectCount;
        }

        function fillEmptySpaces(rng) {
            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (grid[r][c] === '') {
                        grid[r][c] = letters[Math.floor(rng() * letters.length)];
                    }
                }
            }
        }

        // === èªè¼¸åŠŸèƒ½ ===
        function giveUp() {
            if (!isGameActive) return;
            isGameActive = false; 

            btnGiveUp.disabled = true;
            btnGiveUp.classList.add('opacity-50', 'cursor-not-allowed');
            
            btnHeaderNext.classList.add('hidden');

            currentWords.forEach(wordObj => {
                const word = wordObj.en;
                if (!foundWords.has(word)) {
                    if (solutionPaths[word]) {
                        drawHighlightLine(solutionPaths[word], '#ef4444'); 
                    }
                    
                    const li = document.getElementById(`word-${word}`);
                    if (li) {
                        li.classList.add('revealed');
                        li.querySelector('.word-text').textContent = word;
                    }
                }
            });

            setTimeout(() => {
                overlayIcon.textContent = 'ğŸ˜¢';
                overlayTitle.textContent = 'æŒ‘æˆ°å¤±æ•—';
                overlayTitle.className = 'text-3xl font-bold text-red-500 mb-2';
                overlayMessage.textContent = 'åˆ¥æ°£é¤’ï¼Œç­”æ¡ˆå·²ç¶“å¹«ä½ æ¨™å‡ºä¾†äº†ã€‚';
                
                btnNextLevel.classList.add('hidden'); 
                btnPlayAgain.classList.remove('hidden'); 
                winOverlay.classList.remove('hidden');
            }, 800);
        }

        function drawHighlightLine(path, color) {
            const startPos = path[0];
            const endPos = path[path.length - 1];

            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', startPos.c + 0.5);
            line.setAttribute('y1', startPos.r + 0.5);
            line.setAttribute('x2', endPos.c + 0.5);
            line.setAttribute('y2', endPos.r + 0.5);
            line.setAttribute('stroke', color);
            line.setAttribute('stroke-linecap', 'round');
            line.setAttribute('stroke-width', '0.7'); 
            line.setAttribute('pathLength', '100'); 
            line.classList.add('highlight-line');
            highlightLayer.appendChild(line);
        }

        // === UI æ¸²æŸ“ ===

        function renderGrid() {
            gridContainer.querySelectorAll('.cell').forEach(cell => cell.remove());
            
            let fontSizeClass = 'text-lg md:text-xl';
            if (GRID_SIZE <= 8) {
                fontSizeClass = 'text-3xl md:text-4xl';
            } else if (GRID_SIZE <= 12) {
                fontSizeClass = 'text-2xl md:text-3xl';
            } else if (GRID_SIZE > 16) {
                fontSizeClass = 'text-base md:text-lg';
            }

            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.className = `cell flex items-center justify-center ${fontSizeClass} font-bold bg-slate-100 rounded cursor-pointer select-none`;
                    cell.textContent = grid[r][c];
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    cell.id = `cell-${r}-${c}`;
                    gridContainer.appendChild(cell);
                }
            }
        }

        function renderWordList() {
            wordListContainer.innerHTML = '';
            currentWords.forEach(wordObj => {
                const li = document.createElement('li');
                li.className = 'word-item flex items-center gap-2';
                li.id = `word-${wordObj.en}`; 
                
                li.innerHTML = `
                    <svg class="w-5 h-5 opacity-0 transition-opacity text-green-500 check-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>
                    <span class="word-text">${wordObj.zh} <small class="text-slate-400">(${wordObj.en.length})</small></span>
                `;
                wordListContainer.appendChild(li);
            });
        }

        function updateProgress() {
            progressText.textContent = `${foundWords.size} / ${currentWords.length}`;
            
            if (foundWords.size === currentWords.length && isGameActive) {
                isGameActive = false; 

                const currentLvl = parseInt(levelSelect.value);
                const currentStg = parseInt(stageSelect.value);
                const totalStages = getOrGenerateStages(currentLvl).length;
                
                let nextLvl = currentLvl;
                let nextStg = currentStg + 1;
                
                if (nextStg > totalStages) {
                    nextLvl++;
                    nextStg = 1;
                }
                
                saveProgress(nextLvl, nextStg);

                btnGiveUp.classList.add('hidden'); 
                
                if (!(currentLvl >= 6 && currentStg >= totalStages)) {
                    btnHeaderNext.classList.remove('hidden'); 
                }

                setTimeout(() => {
                    overlayIcon.textContent = 'ğŸ‰';
                    overlayTitle.textContent = 'å¤ªå²å®³äº†ï¼';
                    overlayTitle.className = 'text-3xl font-bold text-green-600 mb-2';
                    overlayMessage.textContent = 'ä½ æ‰¾åˆ°äº†æ‰€æœ‰çš„å–®å­—ï¼';
                    
                    if (currentLvl >= 6 && currentStg >= totalStages) {
                        btnNextLevel.classList.add('hidden');
                    } else {
                        btnNextLevel.classList.remove('hidden');
                    }
                    
                    btnPlayAgain.classList.add('hidden'); 
                    winOverlay.classList.remove('hidden');
                }, 500);
            }
        }

        // === äº’å‹•é‚è¼¯ ===

        function handlePointerDown(e) {
            if (!isGameActive) return; 
            isSelecting = true;
            const target = getCellFromEvent(e);
            if (!target) return;

            startCell = { r: parseInt(target.dataset.r), c: parseInt(target.dataset.c) };
            updateSelection(startCell.r, startCell.c);
        }

        function handlePointerMove(e) {
            if (!isGameActive || !isSelecting || !startCell) return;
            e.preventDefault(); 

            const target = getCellFromEvent(e);
            if (!target) return;

            const currentR = parseInt(target.dataset.r);
            const currentC = parseInt(target.dataset.c);
            updateSelection(currentR, currentC);
        }

        function handlePointerUp(e) {
            if (!isSelecting) return;
            isSelecting = false;
            checkSelection();
            clearSelectionUI();
            startCell = null;
        }

        function getCellFromEvent(e) {
            let clientX = e.clientX;
            let clientY = e.clientY;
            
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else if (e.changedTouches && e.changedTouches.length > 0) {
                clientX = e.changedTouches[0].clientX;
                clientY = e.changedTouches[0].clientY;
            }

            const rect = gridContainer.getBoundingClientRect();
            if (clientX < rect.left || clientX > rect.right || clientY < rect.top || clientY > rect.bottom) {
                return null;
            }

            const cellWidth = rect.width / GRID_SIZE;
            const cellHeight = rect.height / GRID_SIZE;

            const c = Math.floor((clientX - rect.left) / cellWidth);
            const r = Math.floor((clientY - rect.top) / cellHeight);

            if (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE) {
                return document.getElementById(`cell-${r}-${c}`);
            }
            return null;
        }

        function updateSelection(endR, endC) {
            currentSelectionLine = calculateLine(startCell.r, startCell.c, endR, endC);
            
            const selectionLine = document.getElementById('selection-line');
            if (selectionLine && currentSelectionLine.length > 0) {
                const startPos = currentSelectionLine[0];
                const endPos = currentSelectionLine[currentSelectionLine.length - 1];
                
                selectionLine.setAttribute('x1', startPos.c + 0.5);
                selectionLine.setAttribute('y1', startPos.r + 0.5);
                selectionLine.setAttribute('x2', endPos.c + 0.5);
                selectionLine.setAttribute('y2', endPos.r + 0.5);
                selectionLine.classList.remove('hidden');
            }
        }

        function calculateLine(r1, c1, r2, c2) {
            const path = [];
            const dr = r2 - r1;
            const dc = c2 - c1;
            
            if (dr !== 0 && dc !== 0 && Math.abs(dr) !== Math.abs(dc)) {
                return [{r: r1, c: c1}]; 
            }

            const stepR = dr === 0 ? 0 : dr / Math.abs(dr);
            const stepC = dc === 0 ? 0 : dc / Math.abs(dc);
            const steps = Math.max(Math.abs(dr), Math.abs(dc));

            for (let i = 0; i <= steps; i++) {
                path.push({ r: r1 + i * stepR, c: c1 + i * stepC });
            }
            return path;
        }

        function clearSelectionUI() {
            const selectionLine = document.getElementById('selection-line');
            if (selectionLine) selectionLine.classList.add('hidden');
        }

        function checkSelection() {
            if (currentSelectionLine.length === 0) return;

            let selectedWord = '';
            currentSelectionLine.forEach(coord => {
                selectedWord += grid[coord.r][coord.c];
            });

            const reversedWord = selectedWord.split('').reverse().join('');

            let foundMatch = null;

            const wordObj = currentWords.find(w => w.en === selectedWord);
            const reversedWordObj = currentWords.find(w => w.en === reversedWord);

            if (wordObj && !foundWords.has(selectedWord)) {
                foundMatch = selectedWord;
            } else if (reversedWordObj && !foundWords.has(reversedWord)) {
                foundMatch = reversedWord;
            }

            if (foundMatch) {
                foundWords.add(foundMatch);
                
                const startPos = currentSelectionLine[0];
                const endPos = currentSelectionLine[currentSelectionLine.length - 1];
                const highlightColors = ['#fde047', '#86efac', '#93c5fd', '#f9a8d4', '#d8b4fe', '#fdba74'];
                const color = highlightColors[(foundWords.size - 1) % highlightColors.length];

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', startPos.c + 0.5);
                line.setAttribute('y1', startPos.r + 0.5);
                line.setAttribute('x2', endPos.c + 0.5);
                line.setAttribute('y2', endPos.r + 0.5);
                line.setAttribute('stroke', color);
                line.setAttribute('stroke-linecap', 'round');
                line.setAttribute('stroke-width', '0.7'); 
                line.setAttribute('pathLength', '100'); 
                line.classList.add('highlight-line');
                highlightLayer.appendChild(line);

                currentSelectionLine.forEach(coord => {
                    const id = `cell-${coord.r}-${coord.c}`;
                    const cell = document.getElementById(id);
                    if (cell) cell.classList.add('scale-110');
                    foundCellCoordinates.add(`${coord.r},${coord.c}`);
                });

                const listItem = document.getElementById(`word-${foundMatch}`);
                if (listItem) {
                    listItem.classList.add('found');
                    listItem.querySelector('.check-icon').classList.remove('opacity-0');
                    
                    const wordObj = currentWords.find(w => w.en === foundMatch);
                    if(wordObj) {
                        listItem.querySelector('.word-text').textContent = wordObj.en;
                    }
                }

                updateProgress();
            }
        }

        // === äº‹ä»¶ç¶å®š ===
        
        gridContainer.addEventListener('pointerdown', handlePointerDown);
        window.addEventListener('pointermove', handlePointerMove, { passive: false });
        window.addEventListener('pointerup', handlePointerUp);
        gridContainer.addEventListener('touchstart', handlePointerDown, { passive: false });
        window.addEventListener('touchmove', handlePointerMove, { passive: false });
        window.addEventListener('touchend', handlePointerUp);

        btnRestart.addEventListener('click', initGame);
        btnPlayAgain.addEventListener('click', initGame);
        btnGiveUp.addEventListener('click', giveUp); 
        
        const goToNextLevel = () => {
            const currentLevelNum = parseInt(levelSelect.value);
            const currentStageNum = parseInt(stageSelect.value);
            const totalStages = getOrGenerateStages(currentLevelNum).length;
            
            if (currentStageNum < totalStages) {
                stageSelect.value = currentStageNum + 1;
                initGame();
            } else if (currentLevelNum < 6) {
                levelSelect.value = currentLevelNum + 1;
                updateStageDropdown(currentLevelNum + 1);
                stageSelect.value = 1;
                initGame();
            }
        };

        btnNextLevel.addEventListener('click', goToNextLevel);
        btnHeaderNext.addEventListener('click', goToNextLevel);
        
        const hideOverlay = () => winOverlay.classList.add('hidden');
        btnCloseOverlay.addEventListener('click', hideOverlay);
        btnViewBoard.addEventListener('click', hideOverlay);

        levelSelect.addEventListener('change', (e) => {
            updateStageDropdown(parseInt(e.target.value));
            initGame();
        });

        stageSelect.addEventListener('change', initGame);

        updateLevelDropdownState();
        updateStageDropdown(1);
        
        if(maxUnlocked.level > 1 || maxUnlocked.stage > 1) {
             levelSelect.value = maxUnlocked.level;
             updateStageDropdown(maxUnlocked.level);
             stageSelect.value = maxUnlocked.stage;
        }
        
        initGame();

    </script>
</body>
</html>
