<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Word Search æ‰¾å­—éŠæˆ² - Mobile Optimized</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap');
        
        body {
            font-family: 'Fredoka', 'Noto Sans TC', sans-serif;
            background-color: #f0fdf4;
            overscroll-behavior-y: none;
            touch-action: pan-x pan-y;
        }

        #grid-container {
            touch-action: none; 
            user-select: none;
            -webkit-user-select: none;
            /* ç¢ºä¿åœ¨æ‰‹æ©Ÿä¸Šä¸æœƒæº¢å‡ºè¢å¹•å¯¬åº¦ */
            max-width: 100vw;
            margin: 0 auto;
        }

        /* é‡å°ä¸åŒç¶²æ ¼å¤§å°å‹•æ…‹èª¿æ•´å­—æ¯ç¸®æ”¾ */
        .cell {
            transition: transform 0.1s;
            line-height: 1;
        }

        .highlight-line {
            stroke-dasharray: 100;
            stroke-dashoffset: 100;
            animation: drawLine 0.4s ease-out forwards;
        }
        
        @keyframes drawLine { to { stroke-dashoffset: 0; } }

        .word-item { transition: all 0.3s ease; }
        .word-item.found {
            text-decoration: line-through;
            color: #9ca3af;
            opacity: 0.6;
        }
        
        /* æ˜Ÿæ˜ŸæŒ‰éˆ• */
        .star-btn { transition: transform 0.2s; cursor: pointer; }
        .star-btn.active { color: #facc15; fill: #facc15; }
        
        @keyframes popIn {
            0% { transform: scale(0.9); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        .animate-pop-in { animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
    </style>
</head>
<body class="h-[100dvh] text-slate-800 flex flex-col items-center overflow-hidden">

    <header class="w-full bg-white shadow-sm border-b border-green-100 z-30 flex-shrink-0">
        <div class="max-w-5xl mx-auto px-4 py-1.5 flex items-center justify-between">
            <div class="flex items-center gap-1">
                <h1 class="text-xl md:text-2xl font-bold text-green-600">Word Search</h1>
                <span id="current-level-display" class="text-[10px] md:text-sm font-medium bg-green-100 text-green-700 px-1.5 py-0.5 rounded ml-1">Level 1 - 1</span>
            </div>
            <button id="btn-open-settings" class="p-1.5 text-slate-500 hover:bg-slate-100 rounded-full">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.09a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.39a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>
            </button>
        </div>
        
        <div class="bg-slate-50 border-t border-slate-100 py-1.5 px-4 flex justify-center gap-2">
            <button id="btn-restart" class="bg-white border border-green-500 text-green-600 px-3 py-1 rounded-full text-xs font-semibold">é‡ä¾†</button>
            <button id="btn-giveup" class="bg-red-50 border border-red-200 text-red-500 px-3 py-1 rounded-full text-xs font-semibold">èªè¼¸</button>
            <button id="btn-header-next" class="hidden bg-blue-500 text-white px-3 py-1 rounded-full text-xs font-semibold animate-pulse">ä¸‹ä¸€é—œ</button>
        </div>
    </header>

    <main class="flex-1 w-full max-w-5xl overflow-hidden p-2 flex flex-col md:flex-row gap-2 items-center md:items-start justify-start">
        
        <div class="w-full max-w-[min(90vw,400px)] bg-white p-1 rounded-xl shadow-md border border-slate-100 relative flex-shrink-0">
            <div id="grid-container" class="grid gap-[1px] w-full aspect-square relative touch-none">
                <svg id="highlight-layer" class="absolute inset-0 w-full h-full pointer-events-none z-10 mix-blend-multiply opacity-80"></svg>
            </div>
            
            <div id="win-overlay" class="hidden absolute inset-0 bg-white/95 backdrop-blur-sm rounded-xl flex flex-col items-center justify-center z-20 animate-pop-in p-4 text-center">
                <div id="overlay-icon" class="text-4xl mb-2">ğŸ‰</div>
                <h2 id="overlay-title" class="text-xl font-bold text-green-600 mb-1">å¤ªå²å®³äº†ï¼</h2>
                <div class="flex flex-wrap gap-2 justify-center">
                    <button id="btn-view-board" class="bg-slate-100 text-slate-600 text-sm py-2 px-4 rounded-full">æŸ¥çœ‹ç›¤é¢</button>
                    <button id="btn-next-level" class="bg-blue-500 text-white text-sm py-2 px-6 rounded-full font-bold">ä¸‹ä¸€é—œ</button>
                    <button id="btn-play-again" class="hidden bg-green-500 text-white text-sm py-2 px-6 rounded-full font-bold">é‡ä¾†ä¸€å±€</button>
                </div>
            </div>
        </div>

        <div class="w-full max-w-[min(90vw,400px)] lg:w-80 bg-white p-3 rounded-xl shadow-sm border border-slate-100 flex flex-col flex-1 min-h-0 overflow-hidden">
            <h3 class="text-sm font-bold text-slate-700 mb-1 border-b pb-1 flex justify-between items-center">
                <span>å°‹æ‰¾å–®å­—</span>
                <span id="progress-text" class="text-[10px] bg-green-100 text-green-700 py-0.5 px-1.5 rounded">0 / 0</span>
            </h3>
            <div class="overflow-y-auto flex-1">
                <ul id="word-list" class="grid grid-cols-2 md:grid-cols-1 gap-x-2 gap-y-1 text-xs">
                    </ul>
            </div>
        </div>
    </main>

    <script>
        // === 1. èª¿æ•´é›£åº¦è¨­å®šï¼šæœ€å¤§ 15x15 ===
        const LEVEL_SETTINGS = {
            1: { minGridSize: 6, maxGridSize: 8, minWords: 4, maxWords: 8 },
            2: { minGridSize: 8, maxGridSize: 10, minWords: 6, maxWords: 10 },
            3: { minGridSize: 9, maxGridSize: 11, minWords: 8, maxWords: 12 },
            4: { minGridSize: 10, maxGridSize: 12, minWords: 10, maxWords: 14 },
            5: { minGridSize: 11, maxGridSize: 13, minWords: 12, maxWords: 16 },
            6: { minGridSize: 12, maxGridSize: 15, minWords: 14, maxWords: 18 }
        };

       

        let GRID_SIZE = 12; 
        let generatedStagesCache = {}; 
        const DIRECTIONS = [
            [0, 1], [1, 0], [1, 1], [-1, 1],
            [0, -1], [-1, 0], [-1, -1], [1, -1]
        ];

        let currentWords = [];
        let grid = [];
        let foundWords = new Set();
        let solutionPaths = {}; 
        let isGameActive = true; 
        let maxUnlocked = { level: 1, stage: 1 }; 
        let globalSeed = 0; // å…¨åŸŸç¨®å­
        let difficultWordsMap = {}; // é›£è©ç´€éŒ„

        let isSelecting = false;
        let startCell = null;
        let currentSelectionLine = [];
        let foundCellCoordinates = new Set(); 

        const gridContainer = document.getElementById('grid-container');
        const highlightLayer = document.getElementById('highlight-layer');
        const wordListContainer = document.getElementById('word-list');
        const levelSelect = document.getElementById('level-select');
        const stageSelect = document.getElementById('stage-select');
        const btnRestart = document.getElementById('btn-restart');
        const btnGiveUp = document.getElementById('btn-giveup'); 
        const btnHeaderNext = document.getElementById('btn-header-next'); 
        const btnDownloadDifficult = document.getElementById('btn-download-difficult'); 
        const btnResetData = document.getElementById('btn-reset-data'); 
        const btnPlayAgain = document.getElementById('btn-play-again');
        const btnNextLevel = document.getElementById('btn-next-level');
        const btnViewBoard = document.getElementById('btn-view-board'); 
        const btnCloseOverlay = document.getElementById('btn-close-overlay'); 
        const winOverlay = document.getElementById('win-overlay');
        const overlayIcon = document.getElementById('overlay-icon');
        const overlayTitle = document.getElementById('overlay-title');
        const overlayMessage = document.getElementById('overlay-message');
        const progressText = document.getElementById('progress-text');
        const currentLevelDisplay = document.getElementById('current-level-display'); // æ–°å¢

        // è¨­å®šé¸å–®ç›¸é—œ DOM
        const settingsModal = document.getElementById('settings-modal');
        const btnOpenSettings = document.getElementById('btn-open-settings');
        const btnCloseSettings = document.getElementById('btn-close-settings');
        const btnBackGame = document.getElementById('btn-back-game');
        
        // === è¨­å®šé¸å–®é‚è¼¯ ===
        function openSettings() {
            settingsModal.classList.remove('hidden');
        }
        function closeSettings() {
            settingsModal.classList.add('hidden');
        }
        btnOpenSettings.addEventListener('click', openSettings);
        btnCloseSettings.addEventListener('click', closeSettings);
        btnBackGame.addEventListener('click', closeSettings);

        // === é€²åº¦èˆ‡ç¨®å­å­˜å–åŠŸèƒ½ ===
        function loadProgress() {
            try {
                const stored = localStorage.getItem('wordSearchProgress');
                return stored ? JSON.parse(stored) : { level: 1, stage: 1 };
            } catch (e) {
                return { level: 1, stage: 1 };
            }
        }

        function loadGlobalSeed() {
            const stored = localStorage.getItem('wordSearchSeed');
            if (stored) return parseInt(stored);
            const newSeed = Math.floor(Math.random() * 999999);
            localStorage.setItem('wordSearchSeed', newSeed);
            return newSeed;
        }

        // è¼‰å…¥é›£è©ç´€éŒ„
        function loadDifficultWords() {
            try {
                const stored = localStorage.getItem('wordSearchDifficultWords');
                if (stored) {
                    difficultWordsMap = JSON.parse(stored);
                }
            } catch (e) {
                console.error("è¼‰å…¥é›£è©å¤±æ•—", e);
            }
        }

        function saveDifficultWords() {
            localStorage.setItem('wordSearchDifficultWords', JSON.stringify(difficultWordsMap));
        }

        // åˆ‡æ›é›£è©æ¨™è¨˜ (Global Scope)
        window.toggleDifficult = function(en, zh, btn) {
            
            if (difficultWordsMap[en]) {
                delete difficultWordsMap[en];
                btn.classList.remove('active');
                btn.classList.add('inactive');
                // è¨­ç‚ºç©ºå¿ƒæ˜Ÿ (SVG path)
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', "M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z");
                path.setAttribute('fill', "none");
                path.setAttribute('stroke', "currentColor");
                path.setAttribute('stroke-width', "2");
                path.setAttribute('stroke-linejoin', "round");
                btn.innerHTML = '';
                btn.appendChild(path);
            } else {
                difficultWordsMap[en] = zh;
                btn.classList.add('active');
                btn.classList.remove('inactive');
                // è¨­ç‚ºå¯¦å¿ƒæ˜Ÿ
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', "M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z");
                path.setAttribute('stroke', "none");
                btn.innerHTML = '';
                btn.appendChild(path);
            }
            saveDifficultWords();
        };

        // ä¸‹è¼‰é›£è©
        function downloadDifficultWords() {
            const words = Object.keys(difficultWordsMap);
            if (words.length === 0) {
                alert("ç›®å‰æ²’æœ‰æ¨™è¨˜ä»»ä½•é›£è©å–”ï¼\nè«‹åœ¨éŠæˆ²ä¸­é»æ“Šå–®å­—æ—çš„æ˜Ÿæ˜Ÿä¾†æ¨™è¨˜ã€‚");
                return;
            }
            
            let content = "Word Search é›£è©è¤‡ç¿’è¡¨\n====================\n\n";
            words.sort().forEach(en => {
                content += `${en} : ${difficultWordsMap[en]}\n`;
            });

            const blob = new Blob([content], { type: "text/plain;charset=utf-8" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "word_search_difficult_words.txt";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function saveProgress(level, stage) {
            if (level > maxUnlocked.level || (level === maxUnlocked.level && stage > maxUnlocked.stage)) {
                maxUnlocked = { level, stage };
                localStorage.setItem('wordSearchProgress', JSON.stringify(maxUnlocked));
                updateLevelDropdownState();
                updateStageDropdown(parseInt(levelSelect.value));
            }
        }

        function resetGameData() {
            if(!confirm('ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰éé—œç´€éŒ„ä¸¦é‡ç½®é¡Œç›®å—ï¼Ÿ\n(é€™å°‡ç„¡æ³•å¾©åŸï¼Œä¸”é¡Œç›®é †åºæœƒå®Œå…¨æ”¹è®Š)\nè¨»ï¼šæ‚¨çš„ã€Œé›£è©ç´€éŒ„ã€ä¸æœƒè¢«æ¸…é™¤ã€‚')) return;
            
            localStorage.removeItem('wordSearchProgress');
            maxUnlocked = { level: 1, stage: 1 };
            
            globalSeed = Math.floor(Math.random() * 999999);
            localStorage.setItem('wordSearchSeed', globalSeed);
            
            generatedStagesCache = {};
            
            updateLevelDropdownState();
            levelSelect.value = 1;
            updateStageDropdown(1);
            stageSelect.value = 1;
            
            initGame();
            closeSettings(); // é‡ç½®å¾Œé—œé–‰é¸å–®
        }
        
        function updateLevelDropdownState() {
            Array.from(levelSelect.options).forEach(opt => {
                const val = parseInt(opt.value);
                const originalText = opt.text.replace('ğŸ”’ ', '');
                if (val > maxUnlocked.level) {
                    opt.disabled = true;
                    opt.textContent = `ğŸ”’ ${originalText}`;
                } else {
                    opt.disabled = false;
                    opt.textContent = originalText;
                }
            });
        }

        // === éŠæˆ²ç”Ÿæˆé‚è¼¯ ===

        function getOrGenerateStages(levelNum) {
            if (generatedStagesCache[levelNum]) {
                return generatedStagesCache[levelNum];
            }

            const settings = LEVEL_SETTINGS[levelNum];
            
            if (!WORDS_DB[levelNum]) {
                console.error("æ‰¾ä¸åˆ° Level è³‡æ–™:", levelNum);
                return [];
            }

            // ä½¿ç”¨ globalSeed ä¾†å½±éŸ¿å–®å­—åˆ†é…ï¼Œé€™æ¨£é‡ç½®å¾Œå–®å­—é †åºæœƒè®Š
            let availableWords = seededShuffle([...WORDS_DB[levelNum]], levelNum + globalSeed);
            
            let stages = [];
            let stageIndex = 0;

            while (availableWords.length > 0) {
                let progressRatio = Math.min(stageIndex / 50, 1);
                let currentGridSize = Math.floor(settings.minGridSize + progressRatio * (settings.maxGridSize - settings.minGridSize));
                let currentWordCount = Math.floor(settings.minWords + progressRatio * (settings.maxWords - settings.minWords));

                let wordsToPick = Math.min(currentWordCount, availableWords.length);
                let stageWords = [];

                for (let i = 0; i < availableWords.length && stageWords.length < wordsToPick; i++) {
                    if (availableWords[i].en.length <= currentGridSize) {
                        stageWords.push(availableWords[i]);
                        availableWords.splice(i, 1);
                        i--; 
                    }
                }

                if (stageWords.length === 0 && availableWords.length > 0) {
                    let minLenIndex = 0;
                    for(let k=1; k<availableWords.length; k++){
                        if(availableWords[k].en.length < availableWords[minLenIndex].en.length){
                            minLenIndex = k;
                        }
                    }
                    currentGridSize = Math.max(currentGridSize, availableWords[minLenIndex].en.length);
                    stageWords.push(availableWords[minLenIndex]);
                    availableWords.splice(minLenIndex, 1);
                }

                stages.push({
                    gridSize: currentGridSize,
                    words: stageWords
                });

                stageIndex++;
                if (stageIndex >= 500) break;
            }

            generatedStagesCache[levelNum] = stages;
            return stages;
        }
        
        function updateStageDropdown(levelNum) {
            const stages = getOrGenerateStages(levelNum);
            const totalStages = stages.length || 1;
            
            let currentStageValue = parseInt(stageSelect.value) || 1;
            
            if (!stageSelect.value && levelNum === maxUnlocked.level) {
                 currentStageValue = maxUnlocked.stage;
            }

            stageSelect.innerHTML = '';
            for (let i = 1; i <= totalStages; i++) {
                const option = document.createElement('option');
                option.value = i;
                
                let isLocked = false;
                if (levelNum > maxUnlocked.level) {
                    isLocked = true;
                } else if (levelNum === maxUnlocked.level && i > maxUnlocked.stage) {
                    isLocked = true;
                }

                if (isLocked) {
                    option.disabled = true;
                    option.textContent = `ğŸ”’ ç¬¬ ${i} é—œ`;
                } else {
                    option.textContent = `ç¬¬ ${i} é—œ`;
                }

                if (i === currentStageValue) option.selected = true;
                stageSelect.appendChild(option);
            }
        }

        function initGame() {
            updateLevelDropdownState();
            const currentLevelNum = parseInt(levelSelect.value);
            
            if(stageSelect.options.length === 0 || !stageSelect.querySelector(`option[value="${stageSelect.value}"]`)) {
                 updateStageDropdown(currentLevelNum);
            }
            
            let currentStageNum = parseInt(stageSelect.value) || 1;
            if (currentLevelNum === maxUnlocked.level && currentStageNum > maxUnlocked.stage) {
                currentStageNum = maxUnlocked.stage;
                stageSelect.value = currentStageNum;
            }

            // æ›´æ–°é ‚éƒ¨é¡¯ç¤º
            currentLevelDisplay.textContent = `Level ${currentLevelNum} - ${currentStageNum}`;

            const stages = getOrGenerateStages(currentLevelNum);
            if (!stages || stages.length === 0) return; 

            const currentStageData = stages[currentStageNum - 1];
            
            GRID_SIZE = currentStageData.gridSize;
            
            // ä½¿ç”¨ globalSeed ä¾†å½±éŸ¿æ¯é—œçš„ç›¤é¢é…ç½®
            const stageSeed = currentLevelNum * 10000 + currentStageNum + globalSeed;
            
            // å¼·åˆ¶è½‰å¤§å¯«
            const wordsToFit = currentStageData.words.map(w => ({
                ...w,
                en: w.en.toUpperCase()
            }));

            gridContainer.style.gridTemplateColumns = `repeat(${GRID_SIZE}, minmax(0, 1fr))`;

            const stageRng = mulberry32(stageSeed);

            const evolutionResult = runEvolutionaryPlacement(wordsToFit, stageRng);
            
            grid = evolutionResult.grid;
            currentWords = evolutionResult.placedWords;
            solutionPaths = evolutionResult.paths;
            
            foundWords.clear();
            foundCellCoordinates.clear();
            isGameActive = true; 
            isSelecting = false;
            startCell = null;
            currentSelectionLine = [];

            highlightLayer.setAttribute('viewBox', `0 0 ${GRID_SIZE} ${GRID_SIZE}`);
            highlightLayer.innerHTML = '<line id="selection-line" stroke="#93c5fd" stroke-linecap="round" stroke-width="0.7" class="hidden" />';

            winOverlay.classList.add('hidden');
            btnGiveUp.classList.remove('hidden'); 
            btnGiveUp.disabled = false; 
            btnGiveUp.classList.remove('opacity-50', 'cursor-not-allowed');
            btnHeaderNext.classList.add('hidden'); 

            fillEmptySpaces(stageRng); 
            renderGrid();
            renderWordList();
            updateProgress();
        }

        // === æ¼”åŒ–æ¼”ç®—æ³•æ ¸å¿ƒ ===
        function runEvolutionaryPlacement(words, rng) {
            const MAX_GENERATIONS = 15;
            let bestGrid = null;
            let bestScore = -1;
            let bestPlacedWords = [];
            let bestPaths = {};

            let currentOrder = seededShuffle([...words], Math.floor(rng() * 10000));

            for (let gen = 0; gen < MAX_GENERATIONS; gen++) {
                const result = tryBuildGrid(currentOrder, rng);
                
                let score = result.placedWords.length * 1000 + result.intersections * 10;

                if (score > bestScore) {
                    bestScore = score;
                    bestGrid = result.grid;
                    bestPlacedWords = result.placedWords;
                    bestPaths = result.paths;
                }

                if (result.failedWords.length > 0) {
                    const successfulShuffled = seededShuffle(result.placedWords.map(w => w.originalObj), Math.floor(rng() * 10000));
                    currentOrder = [...result.failedWords, ...successfulShuffled];
                } else {
                    currentOrder = seededShuffle(currentOrder, Math.floor(rng() * 10000));
                }
            }

            return {
                grid: bestGrid,
                placedWords: bestPlacedWords,
                paths: bestPaths
            };
        }

        function tryBuildGrid(orderedWords, rng) {
            let tempGrid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(''));
            let placedWords = [];
            let failedWords = [];
            let paths = {};
            let intersections = 0;

            for (const wordObj of orderedWords) {
                const word = wordObj.en;
                let placed = false;
                
                let attempts = 0;
                while (!placed && attempts < 50) { 
                    const dir = DIRECTIONS[Math.floor(rng() * DIRECTIONS.length)];
                    const r = Math.floor(rng() * GRID_SIZE);
                    const c = Math.floor(rng() * GRID_SIZE);
                    
                    if (canPlaceWordInGrid(tempGrid, word, r, c, dir[0], dir[1])) {
                        intersections += placeWordInGrid(tempGrid, word, r, c, dir[0], dir[1], paths);
                        placedWords.push(wordObj); 
                        placedWords[placedWords.length-1].originalObj = wordObj; 
                        placed = true;
                    }
                    attempts++;
                }

                if (!placed) {
                    const shuffledDirs = seededShuffle([...DIRECTIONS], Math.floor(rng() * 10000));
                    for (let r = 0; r < GRID_SIZE; r++) {
                        for (let c = 0; c < GRID_SIZE; c++) {
                            for (const dir of shuffledDirs) {
                                if (canPlaceWordInGrid(tempGrid, word, r, c, dir[0], dir[1])) {
                                    intersections += placeWordInGrid(tempGrid, word, r, c, dir[0], dir[1], paths);
                                    placedWords.push(wordObj);
                                    placedWords[placedWords.length-1].originalObj = wordObj;
                                    placed = true;
                                    break;
                                }
                            }
                            if (placed) break;
                        }
                        if (placed) break;
                    }
                }

                if (!placed) {
                    failedWords.push(wordObj);
                }
            }

            return { grid: tempGrid, placedWords, failedWords, paths, intersections };
        }

        function canPlaceWordInGrid(g, word, r, c, dr, dc) {
            const endR = r + (word.length - 1) * dr;
            const endC = c + (word.length - 1) * dc;
            if (endR < 0 || endR >= GRID_SIZE || endC < 0 || endC >= GRID_SIZE) {
                return false;
            }
            for (let i = 0; i < word.length; i++) {
                const cell = g[r + i * dr][c + i * dc];
                if (cell !== '' && cell !== word[i]) return false;
            }
            return true;
        }

        function placeWordInGrid(g, word, r, c, dr, dc, paths) {
            let path = [];
            let intersectCount = 0;
            for (let i = 0; i < word.length; i++) {
                const curR = r + i * dr;
                const curC = c + i * dc;
                if (g[curR][curC] !== '') {
                    intersectCount++; 
                }
                g[curR][curC] = word[i];
                path.push({r: curR, c: curC});
            }
            paths[word] = path;
            return intersectCount;
        }

        function fillEmptySpaces(rng) {
            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (grid[r][c] === '') {
                        grid[r][c] = letters[Math.floor(rng() * letters.length)];
                    }
                }
            }
        }

        // === èªè¼¸åŠŸèƒ½ ===
        function giveUp() {
            if (!isGameActive) return;
            isGameActive = false; 

            btnGiveUp.disabled = true;
            btnGiveUp.classList.add('opacity-50', 'cursor-not-allowed');
            
            btnHeaderNext.classList.add('hidden');

            currentWords.forEach(wordObj => {
                const word = wordObj.en;
                if (!foundWords.has(word)) {
                    if (solutionPaths[word]) {
                        drawHighlightLine(solutionPaths[word], '#ef4444'); 
                    }
                    
                    const li = document.getElementById(`word-${word}`);
                    if (li) {
                        li.classList.add('revealed');
                        // èªè¼¸æ™‚é¡¯ç¤ºè‹±æ–‡
                        li.querySelector('.word-text').textContent = word;
                        // ç§»é™¤ title ä»¥å…å¹²æ“¾
                        li.removeAttribute('title');
                    }
                }
            });

            setTimeout(() => {
                overlayIcon.textContent = 'ğŸ˜¢';
                overlayTitle.textContent = 'æŒ‘æˆ°å¤±æ•—';
                overlayTitle.className = 'text-3xl font-bold text-red-500 mb-2';
                overlayMessage.textContent = 'åˆ¥æ°£é¤’ï¼Œç­”æ¡ˆå·²ç¶“å¹«ä½ æ¨™å‡ºä¾†äº†ã€‚';
                
                btnNextLevel.classList.add('hidden'); 
                btnPlayAgain.classList.remove('hidden'); 
                winOverlay.classList.remove('hidden');
            }, 800);
        }

        function drawHighlightLine(path, color) {
            const startPos = path[0];
            const endPos = path[path.length - 1];

            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', startPos.c + 0.5);
            line.setAttribute('y1', startPos.r + 0.5);
            line.setAttribute('x2', endPos.c + 0.5);
            line.setAttribute('y2', endPos.r + 0.5);
            line.setAttribute('stroke', color);
            line.setAttribute('stroke-linecap', 'round');
            line.setAttribute('stroke-width', '0.7'); 
            line.setAttribute('pathLength', '100'); 
            line.classList.add('highlight-line');
            highlightLayer.appendChild(line);
        }

        // === UI æ¸²æŸ“ ===

// === 2. æ ¸å¿ƒæ¸²æŸ“å„ªåŒ–ï¼šå­—æ¯å¤§å°èª¿æ•´ ===
        function renderGrid() {
            gridContainer.querySelectorAll('.cell').forEach(cell => cell.remove());
            
            // æ ¹æ“šç¶²æ ¼å¤§å°å‹•æ…‹è¨ˆç®—å­—é«”
            let fontSize;
            if (GRID_SIZE <= 8) {
                fontSize = 'text-2xl';
            } else if (GRID_SIZE <= 12) {
                fontSize = 'text-lg';
            } else {
                // 13-15 å¤§å°çš„ç¶²æ ¼ï¼Œåœ¨æ‰‹æ©Ÿä¸Šå­—é«”ç¸®å°åˆ° 14px-16px å·¦å³
                fontSize = 'text-sm md:text-base';
            }

            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = document.createElement('div');
                    // æ¸›å°‘ cell çš„å…§è· (p-0.5)
                    cell.className = `cell flex items-center justify-center ${fontSize} font-bold bg-slate-100 rounded-[2px] cursor-pointer select-none p-0.5`;
                    cell.textContent = grid[r][c];
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    cell.id = `cell-${r}-${c}`;
                    gridContainer.appendChild(cell);
                }
            }
        }

        function renderWordList() {
            wordListContainer.innerHTML = '';
            currentWords.forEach(wordObj => {
                const li = document.createElement('li');
                li.className = 'word-item flex items-start gap-2 relative'; // èª¿æ•´å°é½Š
                li.id = `word-${wordObj.en}`; 
                
                // === ä¸­æ–‡è§£é‡‹æˆªæ–·é‚è¼¯ ===
                const fullText = wordObj.zh;
                // å–ç¬¬ä¸€å€‹åˆ†è™Ÿå‰çš„å…§å®¹
                let displayText = fullText.split(/;|ï¼›/)[0]; // æ”¯æ´å…¨å½¢/åŠå½¢åˆ†è™Ÿ
                
                // å¦‚æœé‚„æ˜¯å¤ªé•·ï¼Œæˆªæ–·åˆ°18å­—å…ƒ
                if (displayText.length > 18) {
                    displayText = displayText.substring(0, 17) + '...';
                }
                // ==========================

                // è¨­å®š title è®“æ»‘é¼ ç§»ä¸Šå»å¯ä»¥çœ‹åˆ°å…¨æ–‡
                li.setAttribute('title', fullText);

                // --- é—œéµä¿®å¾©ï¼šæ­£ç¢ºé¡¯ç¤ºé¦–å­—æ¯èˆ‡å°¾å­—æ¯ ---
                const firstChar = wordObj.en.charAt(0);
                const lastChar = wordObj.en.charAt(wordObj.en.length - 1);
                // è‹±æ–‡å·²è½‰å¤§å¯«ï¼Œç›´æ¥å–ç”¨
                const hintText = `${firstChar}...${lastChar} (${wordObj.en.length})`;

                // æª¢æŸ¥æ˜¯å¦ç‚ºé›£è©
                const isDifficult = !!difficultWordsMap[wordObj.en];
                const starClass = isDifficult ? 'active' : 'inactive';
                
                // SVG Path Data
                const starD = "M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z";

                const starBtn = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                starBtn.setAttribute('viewBox', '0 0 24 24');
                starBtn.setAttribute('class', `w-5 h-5 mt-1 flex-shrink-0 star-btn ${starClass}`);
                
                const starPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                starPath.setAttribute('d', starD);
                
                if (isDifficult) {
                    starPath.setAttribute('stroke', 'none');
                } else {
                    starPath.setAttribute('fill', 'none');
                    starPath.setAttribute('stroke', 'currentColor');
                    starPath.setAttribute('stroke-width', '2');
                    starPath.setAttribute('stroke-linejoin', 'round');
                }
                
                starBtn.appendChild(starPath);

                starBtn.onclick = function(e) {
                    e.stopPropagation(); 
                    toggleDifficult(wordObj.en, fullText, this);
                };

                const checkIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                checkIcon.setAttribute('class', 'w-5 h-5 opacity-0 transition-opacity text-green-500 check-icon mt-1 flex-shrink-0');
                checkIcon.setAttribute('viewBox', '0 0 24 24');
                checkIcon.setAttribute('fill', 'none');
                checkIcon.setAttribute('stroke', 'currentColor');
                checkIcon.setAttribute('stroke-width', '3');
                checkIcon.setAttribute('stroke-linecap', 'round');
                checkIcon.setAttribute('stroke-linejoin', 'round');
                
                const checkPath = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                checkPath.setAttribute('points', '20 6 9 17 4 12');
                checkIcon.appendChild(checkPath);

                const textDiv = document.createElement('div');
                textDiv.className = 'flex flex-col overflow-hidden';
                textDiv.innerHTML = `
                    <span class="word-text truncate text-base leading-tight">${displayText}</span>
                    <small class="text-slate-400 text-xs font-mono tracking-wider">${hintText}</small>
                `;

                li.appendChild(starBtn); 
                li.appendChild(checkIcon);
                li.appendChild(textDiv);
                
                wordListContainer.appendChild(li);
            });
        }

        function updateProgress() {
            progressText.textContent = `${foundWords.size} / ${currentWords.length}`;
            
            if (foundWords.size === currentWords.length && isGameActive) {
                isGameActive = false; 

                const currentLvl = parseInt(levelSelect.value);
                const currentStg = parseInt(stageSelect.value);
                const totalStages = getOrGenerateStages(currentLvl).length;
                
                let nextLvl = currentLvl;
                let nextStg = currentStg + 1;
                
                if (nextStg > totalStages) {
                    nextLvl++;
                    nextStg = 1;
                }
                
                saveProgress(nextLvl, nextStg);

                btnGiveUp.classList.add('hidden'); 
                
                if (!(currentLvl >= 6 && currentStg >= totalStages)) {
                    btnHeaderNext.classList.remove('hidden'); 
                }

                setTimeout(() => {
                    overlayIcon.textContent = 'ğŸ‰';
                    overlayTitle.textContent = 'å¤ªå²å®³äº†ï¼';
                    overlayTitle.className = 'text-3xl font-bold text-green-600 mb-2';
                    overlayMessage.textContent = 'ä½ æ‰¾åˆ°äº†æ‰€æœ‰çš„å–®å­—ï¼';
                    
                    if (currentLvl >= 6 && currentStg >= totalStages) {
                        btnNextLevel.classList.add('hidden');
                    } else {
                        btnNextLevel.classList.remove('hidden');
                    }
                    
                    btnPlayAgain.classList.add('hidden'); 
                    winOverlay.classList.remove('hidden');
                }, 500);
            }
        }

        // === äº’å‹•é‚è¼¯ ===

        function handlePointerDown(e) {
            if (!isGameActive) return; 
            isSelecting = true;
            const target = getCellFromEvent(e);
            if (!target) return;

            startCell = { r: parseInt(target.dataset.r), c: parseInt(target.dataset.c) };
            updateSelection(startCell.r, startCell.c);
        }

        function handlePointerMove(e) {
            if (!isGameActive || !isSelecting || !startCell) return;
            e.preventDefault(); 

            const target = getCellFromEvent(e);
            if (!target) return;

            const currentR = parseInt(target.dataset.r);
            const currentC = parseInt(target.dataset.c);
            updateSelection(currentR, currentC);
        }

        function handlePointerUp(e) {
            if (!isSelecting) return;
            isSelecting = false;
            checkSelection();
            clearSelectionUI();
            startCell = null;
        }

        function getCellFromEvent(e) {
            let clientX = e.clientX;
            let clientY = e.clientY;
            
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else if (e.changedTouches && e.changedTouches.length > 0) {
                clientX = e.changedTouches[0].clientX;
                clientY = e.changedTouches[0].clientY;
            }

            const rect = gridContainer.getBoundingClientRect();
            if (clientX < rect.left || clientX > rect.right || clientY < rect.top || clientY > rect.bottom) {
                return null;
            }

            const cellWidth = rect.width / GRID_SIZE;
            const cellHeight = rect.height / GRID_SIZE;

            const c = Math.floor((clientX - rect.left) / cellWidth);
            const r = Math.floor((clientY - rect.top) / cellHeight);

            if (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE) {
                return document.getElementById(`cell-${r}-${c}`);
            }
            return null;
        }

        function updateSelection(endR, endC) {
            currentSelectionLine = calculateLine(startCell.r, startCell.c, endR, endC);
            
            const selectionLine = document.getElementById('selection-line');
            if (selectionLine && currentSelectionLine.length > 0) {
                const startPos = currentSelectionLine[0];
                const endPos = currentSelectionLine[currentSelectionLine.length - 1];
                
                selectionLine.setAttribute('x1', startPos.c + 0.5);
                selectionLine.setAttribute('y1', startPos.r + 0.5);
                selectionLine.setAttribute('x2', endPos.c + 0.5);
                selectionLine.setAttribute('y2', endPos.r + 0.5);
                selectionLine.classList.remove('hidden');
            }
        }

        function calculateLine(r1, c1, r2, c2) {
            const path = [];
            const dr = r2 - r1;
            const dc = c2 - c1;
            
            if (dr !== 0 && dc !== 0 && Math.abs(dr) !== Math.abs(dc)) {
                return [{r: r1, c: c1}]; 
            }

            const stepR = dr === 0 ? 0 : dr / Math.abs(dr);
            const stepC = dc === 0 ? 0 : dc / Math.abs(dc);
            const steps = Math.max(Math.abs(dr), Math.abs(dc));

            for (let i = 0; i <= steps; i++) {
                path.push({ r: r1 + i * stepR, c: c1 + i * stepC });
            }
            return path;
        }

        function clearSelectionUI() {
            const selectionLine = document.getElementById('selection-line');
            if (selectionLine) selectionLine.classList.add('hidden');
        }

        function checkSelection() {
            if (currentSelectionLine.length === 0) return;

            let selectedWord = '';
            currentSelectionLine.forEach(coord => {
                selectedWord += grid[coord.r][coord.c];
            });

            const reversedWord = selectedWord.split('').reverse().join('');

            let foundMatch = null;

            const wordObj = currentWords.find(w => w.en === selectedWord);
            const reversedWordObj = currentWords.find(w => w.en === reversedWord);

            if (wordObj && !foundWords.has(selectedWord)) {
                foundMatch = selectedWord;
            } else if (reversedWordObj && !foundWords.has(reversedWord)) {
                foundMatch = reversedWord;
            }

            if (foundMatch) {
                foundWords.add(foundMatch);
                
                const startPos = currentSelectionLine[0];
                const endPos = currentSelectionLine[currentSelectionLine.length - 1];
                const highlightColors = ['#fde047', '#86efac', '#93c5fd', '#f9a8d4', '#d8b4fe', '#fdba74'];
                const color = highlightColors[(foundWords.size - 1) % highlightColors.length];

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', startPos.c + 0.5);
                line.setAttribute('y1', startPos.r + 0.5);
                line.setAttribute('x2', endPos.c + 0.5);
                line.setAttribute('y2', endPos.r + 0.5);
                line.setAttribute('stroke', color);
                line.setAttribute('stroke-linecap', 'round');
                line.setAttribute('stroke-width', '0.7'); 
                line.setAttribute('pathLength', '100'); 
                line.classList.add('highlight-line');
                highlightLayer.appendChild(line);

                currentSelectionLine.forEach(coord => {
                    const id = `cell-${coord.r}-${coord.c}`;
                    const cell = document.getElementById(id);
                    if (cell) cell.classList.add('scale-110');
                    foundCellCoordinates.add(`${coord.r},${coord.c}`);
                });

                const listItem = document.getElementById(`word-${foundMatch}`);
                if (listItem) {
                    listItem.classList.add('found');
                    listItem.querySelector('.check-icon').classList.remove('opacity-0');
                    
                    const wordObj = currentWords.find(w => w.en === foundMatch);
                    if(wordObj) {
                        listItem.querySelector('.word-text').textContent = wordObj.en;
                    }
                    // ç§»é™¤ title
                    listItem.removeAttribute('title');
                }

                updateProgress();
            }
        }

        // === äº‹ä»¶ç¶å®šèˆ‡åˆå§‹åŒ– ===
        
        function initializeGameSystem() {
            maxUnlocked = loadProgress();
            globalSeed = loadGlobalSeed(); 
            loadDifficultWords(); 
            
            gridContainer.addEventListener('pointerdown', handlePointerDown);
            window.addEventListener('pointermove', handlePointerMove, { passive: false });
            window.addEventListener('pointerup', handlePointerUp);
            gridContainer.addEventListener('touchstart', handlePointerDown, { passive: false });
            window.addEventListener('touchmove', handlePointerMove, { passive: false });
            window.addEventListener('touchend', handlePointerUp);

            btnRestart.addEventListener('click', initGame);
            btnPlayAgain.addEventListener('click', initGame);
            btnGiveUp.addEventListener('click', giveUp); 
            btnResetData.addEventListener('click', resetGameData); 
            btnDownloadDifficult.addEventListener('click', downloadDifficultWords); 
            
            const goToNextLevel = () => {
                const currentLevelNum = parseInt(levelSelect.value);
                const currentStageNum = parseInt(stageSelect.value);
                const totalStages = getOrGenerateStages(currentLevelNum).length;
                
                if (currentStageNum < totalStages) {
                    stageSelect.value = currentStageNum + 1;
                    initGame();
                } else if (currentLevelNum < 6) {
                    levelSelect.value = currentLevelNum + 1;
                    updateStageDropdown(currentLevelNum + 1);
                    stageSelect.value = 1;
                    initGame();
                }
            };

            btnNextLevel.addEventListener('click', goToNextLevel);
            btnHeaderNext.addEventListener('click', goToNextLevel);
            
            const hideOverlay = () => winOverlay.classList.add('hidden');
            btnCloseOverlay.addEventListener('click', hideOverlay);
            btnViewBoard.addEventListener('click', hideOverlay);

            levelSelect.addEventListener('change', (e) => {
                updateStageDropdown(parseInt(e.target.value));
                initGame();
            });

            stageSelect.addEventListener('change', initGame);

            updateLevelDropdownState();
            updateStageDropdown(1);
            
            if(maxUnlocked.level > 1 || maxUnlocked.stage > 1) {
                 levelSelect.value = maxUnlocked.level;
                 updateStageDropdown(maxUnlocked.level);
                 stageSelect.value = maxUnlocked.stage;
            }
            
            // çœŸæ­£é–‹å§‹ç¬¬ä¸€å±€
            initGame();
        }

        // ç¨‹å¼é€²å…¥é»
        initializeGameSystem();

    </script>
</body>
</html>

